
extern crate glfw;

use gfx;
use gfx::gl;
use gfx::input::Event;

use std::sync::mpsc::Receiver;
use std::collections::LinkedList;

pub struct Backend
{
    glfw: glfw::Glfw,
    window: glfw::Window,
    events: Receiver<(f64,glfw::WindowEvent)>,
}

impl Backend
{
    pub fn new() -> Backend {
        use self::glfw::Context;


        let glfw = glfw::init(glfw::FAIL_ON_ERRORS).unwrap();

        let (mut window, events) = glfw.create_window(500,500,
                                                      gl::backends::DEFAULT_TITLE,
                                                      glfw::WindowMode::Windowed)
                                       .expect("Failed to create GLFW window");

        gfx::gl::gl::load_with(|s| window.get_proc_address(s));

        window.set_key_polling(true);
        window.make_current();

        Backend {
            glfw: glfw,
            window: window,
            events: events,
        }
    }
}

impl gfx::gl::Backend for Backend
{
    fn run(&mut self, events: &mut LinkedList<Event>) {
        self.glfw.poll_events();

        for (_,event) in glfw::flush_messages(&self.events) {
            match self::util::into_event(event) {
                Some(e) => {
                    events.push_back(e);
                },
                None => (),
            }
        }
    }

    fn end(&mut self) {
        use self::glfw::Context;
        self.window.swap_buffers()
    }

    fn is_open(&self) -> bool {
        !self.window.should_close()
    }

    fn dimensions(&self) -> (u32,u32) {
        let (width,height) = self.window.get_size();
        (width as u32, height as u32)
    }

    fn set_title(&mut self, title: &str) {
        self.window.set_title(title)
    }
}

/// Useful utilities.
pub mod util
{
    use super::glfw;
    use gfx::input::{self,Event};

    pub fn into_event(event: glfw::WindowEvent) -> Option<Event> {
        match event {
            glfw::WindowEvent::Key(gkey, _, gaction, _) => {
                let action = match into_action(gaction) {
                    Some(a) => a,
                    None => { return None; },
                };

                let key = match into_key(gkey) {
                    Some(key) => key,
                    None => { return None; },
                };

                Some(Event::Key(key, action))

            },
            _ => unimplemented!(),
        }
    }

    pub fn into_action(action: glfw::Action) -> Option<input::Action> {
        match action {
            glfw::Action::Press => Some(input::Action::Press),
            glfw::Action::Release => Some(input::Action::Release),
            _ => None, // we don't handle this
        }
    }

    pub fn into_key(key: glfw::Key) -> Option<input::Key> {
        use input::Key;

        match key {
            glfw::Key::Space => Some(Key::Space),
            glfw::Key::Apostrophe => Some(Key::Apostrophe),
            glfw::Key::Comma => Some(Key::Comma),
            glfw::Key::Minus => Some(Key::Minus),
            glfw::Key::Period => Some(Key::Period),
            glfw::Key::Slash => Some(Key::Slash),
            glfw::Key::Num0 => Some(Key::Num(0, input::NumberSource::Row)),
            glfw::Key::Num1 => Some(Key::Num(1, input::NumberSource::Row)),
            glfw::Key::Num2 => Some(Key::Num(2, input::NumberSource::Row)),
            glfw::Key::Num3 => Some(Key::Num(3, input::NumberSource::Row)),
            glfw::Key::Num4 => Some(Key::Num(4, input::NumberSource::Row)),
            glfw::Key::Num5 => Some(Key::Num(5, input::NumberSource::Row)),
            glfw::Key::Num6 => Some(Key::Num(6, input::NumberSource::Row)),
            glfw::Key::Num7 => Some(Key::Num(7, input::NumberSource::Row)),
            glfw::Key::Num8 => Some(Key::Num(8, input::NumberSource::Row)),
            glfw::Key::Num9 => Some(Key::Num(9, input::NumberSource::Row)),
            _ => unimplemented!(),
        }
    }
}
